---
layout: post
title: "Always Learn, part 2 - What again?"
categories: website
author: "cliveleehere"
---

In the [first part]({% link _posts/2019-03-14-always-learn-pt-1.md %}) of this series about always learning as a software developer, I suggested learning about:

1) something that's *tangential* to what you're working on;
2) or some tool that will *improve* your development environment or process.

The rationale was to minimize the mental overhead caused by context switching, thereby making constant incremental improvements.

But there are downsides to this approach:
- This approach won't allow you to learn something that's completely different from what you already know.  
- This approach may keep you in a niche which over time turns out to be not as lucrative.

So we have to tweak our formula here on 'what' we should learn.

<p align="center">
    ...
</p>

The opposite of taking a small incremental step is to take a huge one.  Sometime, if you're stuck in a local maximum, you need to take a giant step in *some* direction.  Easy, right?

This can be scary, at least it is for me.  There are two reasons to be scared (and these reasons related to the downsides of the tangential approach above).  
- There's always a *cost* to learning something new.  The cost isn't just measure by time, effort, resources, as well as opportunity cost, but also by the *distance* of the step, as in how big of a conceptual gap exists between what you already know vs. what you're trying to learn.  
- There's always a *risk* that what you learn may turn out to be not very beneficial.  A library may stop being maintained.  A framework may become outdated.  A language may fall off the TIOBE index.  And you're going to feel like you've wasted a lot of time for nothing.  

It can be daunting even deciding what to learn.

<p align="center">
    ...
</p>

So here are some heuristics that I've used when decide whether to learn something that required significant investment.

1. Maturity & Future Viability

    Don't be the first one in the pool.  Don't be the second, either.  Be about the third, and make sure there are big players who rely on the said pool and have incentives to keep the pool well-maintained. (There are other reasons to jump in first such as name recognition, or you may want to write or give a talk about the pool).  Okay, so I'm stretching the analogy a bit here, but you get the idea.  Assess the maturity and future viability of whatever you might learn (and there are tools online that help with this, like ThoughtWorks radar!)

2. A Clear Destination
    
    I got back into programming because I thought I had a killer idea.  Turns out my idea was too hard for me to execute, but along the way I picked up some skills that made me employable.  Along the journey, as I took these huge, costly steps, I learned enough to change my destination, to course correct.  So lay out a clear destination of what you want to build, or what you want to learn, and how you will get there.  And chart a path with potential exits and side roads.  

3. Same Mountain, Different Path

    Rewriting [old software]({% link _posts/2019-03-06-rewriting-experience.md %}) can be a good way to decide on what to learn.  It's *tangential* not in the tech stack that you know, but in terms of domain knowledge you already have.  Because you know *what* to build already, you can invest more in *how* to rebuild it.  The familiar mountain terrain may be easier to navigate, the familiar sights guiding your path to the summit, even as you chart a new path.

4. "TOO COOL!!"

    We're geeks.  Sometimes the more you hear about something, the more you want to learn how to use it.  "For Jacob loved Rebecca, and seven years seemed like days."

That's it for now! Hope this helps you, dear reader, in deciding what huge, adventures you will take next! (along with the tangential improvements, of course!)